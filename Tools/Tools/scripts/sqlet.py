#!/usr/bin/python

import sys
import getopt
import os
import shutil
import re


class TableInfo:

    def __init__(self,name,delimiter,fname):
        self.name = name
        self.delimiter = delimiter
        self.fname = fname

        self.colNames = []
        self.colTypes = []
        self.colSampleValues = []

    def setColNamesTypes(self,firstLine,header,LR,LI):
        if header in (0,-1):
            prefix = self.name.lower()
            colcount = firstLine.count(self.delimiter) + 1
            for i in range(1,colcount+1):
                self.colNames.append(prefix + str(i))
                self.colTypes.append(getType(i,LR,LI))
        else:
            headerNames = firstLine.split(self.delimiter)
            for i in range(0,len(headerNames)):
                self.colNames.append(headerNames[i])
                self.colTypes.append(getType(i+1,LR,LI))
                if not re.match('^[a-zA-Z_][a-zA-Z0-9_]*$', headerNames[i]):
                    WARN( 'column ' +str(i+1)+ ' in table ' + self.name + ' is named \'' + headerNames[i] + '\'' )
                    WARN( '    try using sqare brackets (eg, \'['+headerNames[i]+']\') in SQL statement,' )
                    WARN( '    or option \'-h-1\' do discard headers and use column names x1, x2,.. for table X' )

    def setSampleValues(self,line):
        self.colSampleValues = line.split(self.delimiter)

    def getColNamesTypesString(self):
        RET = '[' + self.colNames[0] + '] ' + self.colTypes[0]
        for i in range(1,len(self.colNames)):
            RET += ', [' + self.colNames[i] + '] ' + self.colTypes[i]
        return RET

    def getSql(self):
        RET = []
        RET.append( 'create table ' + self.name + '(' + self.getColNamesTypesString() + ');')
        RET.append( '.import ' + self.fname + ' ' + self.name )
        RET.append( '----------------------------------------------' )
        return RET

    def getInfo(self):
        RET = []
        RET.append( '-- new table..' )
        RET.append( '-- table name: ' + self.name )
        RET.append( '-- file name: ' + self.fname )
        RET.append( '-- colIndex -- colName -- colType -- sampleValue' )
        for i in range(0,len(self.colNames)):
            RET.append('-- ' + str(i+1) + ' -- ' + self.colNames[i] + ' -- ' + self.colTypes[i] + ' -- ' + self.colSampleValues[i])
        return RET






def usage():
    print >> sys.stderr, """
Usage: sqlet.py [OPTIONS] -A fileName1.txt [OPTIONS] -B fileName2 .. [OPTIONS] '<SqlCommand1>' '<SqlCommand2>' .. | sqlite3

SQLet directly executes SQL commands on multiple text files via the Linux command line.
(Version: 1.01)


EXAMPLES:

Consider a space-separated text file with a header line:

>cat file1_h.txt
NAME KEY VALUE
foo 11 3.14
bar 12 2.71
foobar 12 .007


** The following command performs a simple select statement on this file:

>sqlet.py  -A file1_h.txt  'select * from A where a2="12";'  | sqlite3
bar 12 2.71
foobar 12 .007

This reads in the text file into an SQL table called 'A', automatically
naming the columns a1-a3, and executes the given SQL statement.


** The header line's column names can be used with the '-h1' flag:

>sqlet.py  -h1  -A file1_h.txt  'select * from A where KEY="12";'  | sqlite3
bar 12 2.71
foobar 12 .007


** By default, all columns are of type TEXT.  The following command
interprets column 2 as INTEGER column (note the '>' instead of '=' operator):

>sqlet.py  -h1  -i2  -A file1_h.txt  'select * from A where KEY>11;'  | sqlite3
bar 12 2.71
foobar 12 .007

The following command interprets columns 2 and 3 as REAL columns:

>sqlet.py  -h1  -r2,3  -A file1_h.txt  'select * from A where KEY>11;'  | sqlite3
bar 12 2.71
foobar 12 .007


** SQLet can operate on several files at once.  Consider a second file
without header, and a different delimiter:

>cat file2.txt
categoryX;10
categoryY;11
categoryZ;12

The following command loads file1 (with header, default delimiter=' '), 
loads file2 (no header, delimiter=';'), performs a join, and outputs
the results using the new delimiter '|':

>sqlet.py  -h1  -A file1_h.txt  -h0  -d';'  -B file2.txt  -d'|'  'select * from A,B where KEY=b2;'  | sqlite3
foo|11|3.14|categoryY|11
bar|12|2.71|categoryZ|12
foobar|12|.007|categoryZ|12


** To debug the SQL generated by SQLet, omit the final pipe to sqlite3:

>sqlet.py  -h1  -A file1_h.txt  -h0  -d';'  -B file2.txt  -d'|'  'select * from A,B where KEY=b2;'
.separator ' '
----------------------------------------------
-- table name: A
-- file name: file1_h.txt.21535.NO_HEADER.sqlet.tmp
-- 0 -- NAME -- TEXT -- foo
-- 1 -- KEY -- TEXT -- 11
-- 2 -- VALUE -- TEXT -- 3.14
----------------------------------------------
create table A(NAME TEXT, KEY TEXT, VALUE TEXT);
.import file1_h.txt.21535.NO_HEADER.sqlet.tmp A
.separator ';'
----------------------------------------------
-- table name: B
-- file name: file2.txt
-- 0 -- b1 -- TEXT -- categoryX
-- 1 -- b2 -- TEXT -- 10
----------------------------------------------
create table B(b1 TEXT, b2 TEXT);
.import file2.txt B
.separator '|'
select * from A,B where KEY=b2;
drop table A;
drop table B;



LIST OF OPTIONS:

-d'X'    [eg, -d';']   Sets the input/output delimiter for 
                       subsequent reads/selects  (default=' ')

-h1                    Use header for column names
-h-1                   Header is ignored; use numbered columns instead
-h0                    No header (default)

-iN      [eg, -i2]     Column N is INTEGER type
-iN,M,.. [eg, -i2,4]   Columns N,M,.. are INTEGER type

-rN      [eg, -r2]     Column N is REAL type
-rN,M,.. [eg, -r2,4]   Columns N,M,.. are REAL type
  
-A file1  -B file2  -C file3  ..
                       Loads files into tables A, B, C,..
                       The options above can be used between -X and -Y calls
                       Column types must be set for each file/table separately,
                           preceding its -X command

"""


def getType(i,LR,LI):
    if i in LR:
        return 'REAL'
    elif i in LI:
        return 'INTEGER'
    return 'TEXT'



def EXIT(text):
    print >> sys.stderr, 'ERROR: sqlet.py: ' + text
    sys.exit(2)

def WARN(text):
    print >> sys.stderr, 'WARNING: sqlet.py: ' + text


def main(argv):                          
    try:                                
        opts, args = getopt.getopt(argv, "h:d:i:r:A:B:C:D:E:F:G:H:I:J:K:L:M:N:O:P:Q:R:S:T:U:V:W:X:Y:Z:", [])
    except:
        EXIT( 'invalid option used; run without options to see usage, tutorial, and option list' )          

    if not opts:
        usage()
        sys.exit(2)

    processId = os.getpid()

    delimiter = ' '

    indicesInt = []
    indicesReal = []

    commands = []
    commandsEnd = []
    commandsEnd.append( '----------------------------------------------' )

    header = 0 

    commands.append( '----------------------------------------------' )
    commands.append( '-- SQLet interprets its arguments to generate the following SQL commands; pipe to sqlite3 to execute' )
    commands.append( '----------------------------------------------' )
    commands.append( '-- defaults:' )
    commands.append( '.separator \'' + delimiter + '\'' )
    commands.append( '.header off' )
    commands.append( '----------------------------------------------' )
   
    for opt, arg in opts:                
        if opt == '-h':      
            header = int(arg)
            if not header in (-1,0,1):
                EXIT( 'invalid -h value; must be 0,1, or -1' )
            commands.append( '-- override header handling for all following tables; set to ' + str(header) )
 
        elif opt == '-d':                
            delimiter = arg
            if len(delimiter) != 1:
                EXIT( 'delimiter must be a single character' )
            commands.append( '.separator \'' + delimiter + '\'' )

        elif opt == '-i':
            tmpLS = arg.split(',')
            try:
                tmpLI = map(int, tmpLS)
            except:
                EXIT( 'the -i option requires an integer, or several comma-separated integers' )
            indicesInt.extend(tmpLI)
            commands.append( '-- override TEXT column type for next new table; column/s ' + str(tmpLI) + ' set to INTEGER' )

        elif opt == '-r':
            tmpLS = arg.split(',')
            try:
                tmpLI = map(int, tmpLS)
            except:
                EXIT( 'the -r option requires an integer, or several comma-separated integers' )
            indicesReal.extend(tmpLI)
            commands.append( '-- override TEXT column type for next new table; column/s ' + str(tmpLI) + ' set to REAL' )

        elif opt in ('-A','-B','-C','-D','-E','-F','-G','-H','-I','-J','-K','-L','-M','-N','-O','-P','-Q','-R','-S','-T','-U','-V','-W','-X','-Y','-Z'):
            tableName = opt[1:2]

            fname = arg

            try:
                infile = open(fname,'r'); firstLine = infile.readline().rstrip('\n'); infile.close()
            except:
                EXIT( 'file ' + fname + ' not found' )

            fnameEFFECTIVE = fname
            if header in (1,-1):
                fnameEFFECTIVE = fname+"."+str(processId)+".NO_HEADER.sqlet.tmp"
                os.system('tail -n +2 '+fname+' > '+fnameEFFECTIVE)

            infile = open(fnameEFFECTIVE,'r'); firstDataLine = infile.readline().rstrip('\n'); infile.close()

            ti = TableInfo(tableName,delimiter,fnameEFFECTIVE)
            ti.setColNamesTypes(firstLine,header,indicesReal,indicesInt)
            ti.setSampleValues(firstDataLine)

            commands.extend(ti.getInfo())
            commands.extend(ti.getSql())
            commandsEnd.append( 'drop table ' + tableName + ';' )


            indicesInt = []
            indicesReal = []


    for c in commands:
        print c

    for a in args:
        print a
        #if a[-1] == ';':
        #    print a
        #else:
        #    print a + ';'

    commandsEnd.append( '----------------------------------------------' )
    for c in commandsEnd:
        print c






if __name__ == "__main__":
    main(sys.argv[1:])



